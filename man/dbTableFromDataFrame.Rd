% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dbTableFromDataFrame.R
\name{dbTableFromDataFrame}
\alias{dbTableFromDataFrame}
\title{Create a table in a SQLite database from a data frame}
\usage{
dbTableFromDataFrame(
  df,
  dbcon,
  table_name,
  id_quote_method = "DB_NAMES",
  col_names = NULL,
  col_types = NULL,
  drop_table = FALSE,
  auto_pk = FALSE,
  build_pk = FALSE,
  pk_fields = NULL
)
}
\arguments{
\item{df}{the data frame to be saved in the SQLite table.}

\item{dbcon}{database connection, as created by the dbConnect function.}

\item{table_name}{character, the name of the table.}

\item{id_quote_method}{character, used to specify how to build the SQLite
columns' names using the fields' identifiers read from the input file.
For details see the description of the \code{quote_method} parameter of
the \code{\link[=format_column_names]{format_column_names()}} function. Defautls to \code{DB_NAMES}.}

\item{col_names}{character vector, names of the columuns to be imported.
Used to override the field names derived from the data frame (using the
quote method selected by \code{id_quote_method}). Must be of the same length
of the number of columns in the data frame. If \code{NULL} the column names
coming from the input (after quoting) will be used. Defaults to \code{NULL}.}

\item{col_types}{character vector of classes to be assumed for the columns.
If not null, it will override the data types inferred from the input data
frame. Must be of the same length of the number of columns in the input.
If \code{NULL} the data type inferred from the input will be used.
Defaults to \code{NULL}.}

\item{drop_table}{logical, if \code{TRUE} the target table will be dropped
(if exists) and recreated before importing the data.  if \code{FALSE},
data from input data frame will be appended to an existing table.
Defaults to \code{FALSE}.}

\item{auto_pk}{logical, if \code{TRUE}, and \code{pk_fields} parameter is \code{NULL}, an
additional column named \code{SEQ} will be added to the table and it will be
defined to be \verb{INTEGER PRIMARY KEY} (i.e. in effect an alias for
\code{ROWID}). Defaults to \code{FALSE}.}

\item{build_pk}{logical, if \code{TRUE} creates a \verb{UNIQUE INDEX} named
\verb{<table_name>_PK} defined by the combination of fields specified
in the \code{pk_fields} parameter. It will be effective only if
\code{pk_fields} is not null. Defaults to \code{FALSE}.}

\item{pk_fields}{character vector, the list of the fields' names that
define the \verb{UNIQUE INDEX}. Defaults to \code{NULL}.}
}
\value{
integer, the number of records in \code{table_name} after reading data
from the data frame.
}
\description{
The \code{dbTableFromDataFrame()} function reads the data from a rectangula region
of a sheet in an Excel file and copies it to a table in a SQLite
database. If table does not exist, it will create it.
}
\examples{
# Create a temporary database and load data frame
# Set up database connection
dbcon <- dbConnect(RSQLite::SQLite(), file.path(tempdir(), "example.sqlite"))

# Create a sample data frame
sample_data <- data.frame(
  id = 1:10,
  name = paste0("Item_", 1:10),
  value = runif(10, 1, 100),
  active = c(TRUE, FALSE),
  date = Sys.Date() + 0:9,
  stringsAsFactors = FALSE,
  row.names = NULL
)

# Load data frame with automatic primary key
dbTableFromDataFrame(
  df = sample_data,
  dbcon = dbcon,
  table_name = "SAMPLE_DATA",
  drop_table = TRUE,
  auto_pk = TRUE  
)

# Check the imported data
dbListFields(dbcon, "SAMPLE_DATA")
dbGetQuery(dbcon, "SELECT * FROM SAMPLE_DATA LIMIT 5")

# Load with column selection and custom naming
dbTableFromDataFrame(
  df = sample_data,
  dbcon = dbcon,
  table_name = "SAMPLE_SUBSET",
  drop_table = TRUE,
  col_names = c("ID", "ITEM_NAME", "ITEM_VALUE", "IS_ACTIVE", "DATE_CREATED")
)

dbGetQuery(dbcon, "SELECT * FROM SAMPLE_SUBSET LIMIT 5")

# Clean up
dbDisconnect(dbcon)

}
